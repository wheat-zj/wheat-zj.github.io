---
layout:     post
title:      Git Command
subtitle:   对网络编程整理
date:       2018-06-08
author:     WHEAT
header-img: img/git1.png
catalog: true
tags:
    - UDP-TCP
---
### UDP
##### 是一种无须连接的快速传输(广播,电视,对数据要求不高)
	import socket
	#建立udp套接字
	udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM )
	#设置允许发送广播
	udp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, True)
	# 发送消息
    	udp_socket.sendto('内容'.encode("utf-8"), ("255.255.255.255", 9090))
	# 接收数据
    	recv_data = udp_socket.recvfrom(1024)
	# 关闭套接字
    	udp_socket.close()


### TCP
#####面向连接(一对一的连接)
#####可靠传输
	1）TCP采用发送应答机制
	TCP发送的每个报文段都必须得到接收方的应答才认为这个TCP报文段传输成功
	2）超时重传
	发送端发出一个报文段之后就启动定时器，如果在定时时间内没有收到应答就重新发送这个报文段
	3）错误校验
	TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和
	4) 流量控制和阻塞管理
	流量控制用来避免主机发送得过快而使接收方来不及完全收下
	
#####说明代码 	
	from socket import *
	# 创建socket
	tcp_server_socket = socket(AF_INET, SOCK_STREAM)
	# socket.SO_REUSEADD 设置地址重用  True 可以重用  False 不能重用
	tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
	# 绑定
	tcp_server_socket.bind('',7788)

	# 使用socket创建的套接字默认的属性是主动的，使用listen将其变为被动的
	#客服端要主动联接tcp_client_socket.connect(("192.168.31.247", 7878))
	tcp_server_socket.listen(128)
	# 如果有新的客户端来链接服务器，那么就产生一个新的套接字专门为这个客户端服务
	# client_socket用来为这个客户端服务
	# tcp_server_socket就可以省下来专门等待其他新客户端的链接
	client_socket, ip_port = tcp_server_socket.accept()
	# 接收对方发送过来的数据
	recv_data = client_socket.recv(1024)
	print('收到数据：%s' % recv_data.decode('gbk'))
	# 发送一些数据到客户端
	client_socket.send("好的，已经收到！～".encode('gbk'))
	# 关闭为这个客户端服务的套接字，只要关闭了，就意味着为不能再为这个客户端服务了，如果还需要服务，只能再次重新连接
	client_socket.close()

#####TCP的3次握手
	（1）第⼀次握⼿：Client将标志位SYN置为1，随机产⽣⼀个值seq=J，并将该数据包发送给Server， Client进⼊SYN_SENT状态，等待Server确认。

	（2）第⼆次握⼿：Server收到数据包后由标志位SYN=1知道Client请求建⽴连接，Server将标志位 SYN和ACK都置为1，ack=J+1，随机产⽣⼀个值seq=K，并将该数据包发送给Client以确认连接请求,Server进⼊SYN_RCVD状态。

	（3）第三次握⼿：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK 置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确 则连接建⽴成功，Client和Server进⼊ESTABLISHED状态，完成三次握⼿，随后Client与Server之间 可以开始传输数据了。

#####TCP的4次挥手
	(1)第⼀次挥⼿：主机1（可以是客户端，也可以是服务器端），设置 Sequence Number 和 Acknowledgment Number ，向主机2发送⼀个 FIN 报⽂段；此时，主机1进 ⼊ FIN_WAIT_1 状态；这表示主机1没有数据要发送给主机2了；

	(2)第⼆次挥⼿：主机2收到了主机1发送的 FIN 报⽂段，向主机1回⼀个 ACK 报⽂段， Acknowledgment Number 为 Sequence Number 加1；主机1进⼊ FIN_WAIT_2 状态；主机2告诉主机1，我也没有数据要 发送了，可以进⾏关闭连接了；

	(3)第三次挥⼿：主机2向主机1发送 FIN 报⽂段，请求关闭连接，同时主机2进⼊ CLOSE_WAIT 状态；

	(4)第四次挥⼿：主机1收到主机2发送的 FIN 报⽂段，向主机2发送 ACK 报⽂段，然后主机1进 ⼊ TIME_WAIT 状态；主机2收到主机1的 ACK 报⽂段以后，就关闭连接；此时，主机1等待2MSL后依 然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。
	





